---
title: 源码分析-Vue从初始化到挂载DOM
date: 2022-04-27
tags:
 - Vue
categories:
 -  Vue
---
> 基于 Vue 版本："2.5.21"，Vue 的源码非常的复杂，先从整体看 Vue 的实现，后面再根据具体需要看细节实现




当前2.x版本的Vue实现是一个函数，如下可以看到使用函数的好处是可以将Vue当做参数传递，这样就可以在它的 prototype 上扩展一些方法，相当于分模块进行处理，方便代码的维护和管理，同时也有利于读者对代码的理解，一眼就能大致看出哪个模块做了什么，new Vue() 的时候，执行了 this._init() 方法

```js
//  .src/core/instance/index.js

import { initMixin } from './init'
import { stateMixin } from './state'
import { renderMixin } from './render'
import { eventsMixin } from './events'
import { lifecycleMixin } from './lifecycle'
import { warn } from '../util/index'

function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}

// 把Vue当作参数传递，它的功能都是给Vue的 prototype 上扩展一些方法，这样做相当于分模块进行处理，方便的代码的维护和管理
initMixin(Vue)  // _init() 在这里实现
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue

```

_init() 主要合并配置，初始化数据，在这里执行了生命周期钩子 beforeCreate，created，显然 beforeCreate 的钩⼦函数中就不能获取到 props 、 data 中定义的值，也不能调⽤ methods 中定义的函数。beforeCreate 之前仅仅是初始化了一些全局事件和生命周期，具体的数据初始化在 initState 中进行的，而这个方法是在 beforeCreate 之后 created 之前被调用的，所以我们可以在 created 生命周期中调用 props，data，methods等等。这个方法的最终会调用 vm.$mount()

```js
//  .src/core/instance/init.js，只保留了关键代码

Vue.prototype._init = function (options?: Object) {
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options)
    } else {
      // 合并配置，vue有默认配置
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }
    // expose real self
    vm._self = vm
    // 初始化生命周期
    initLifecycle(vm)
    // 初始化事件
    initEvents(vm)
    initRender(vm)
    // 执行生命周期钩子函数 beforeCreate
    callHook(vm, 'beforeCreate')
    initInjections(vm) // resolve injections before data/props
    // 初始化 props 、 data 、 methods 、 watch 、 computed 等属性，
    //显然 beforeCreate 的钩⼦函数中就不能获取到 props 、 data 中定义的值，也不能调⽤ methods 中定义的函数。
    // 但是在created方法中就可以，所以网络请求数据可以放在created方法中进行
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    /* 在这俩个钩⼦函数执⾏的时候，并没有渲染 DOM，所以我们也不能够访问 DOM，⼀般来说，如果组
    件在加载的时候需要和后端有交互，放在这俩个钩⼦函数执⾏都可以，如果是需要访问
    props 、 data 等数据的话，就需要使⽤ created 钩⼦函数。 */
    // 执行生命周期钩子函数 created
    callHook(vm, 'created')

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }
    // 最终会执行 $mount  ---> mountComponent --->  _render()  --->  _update()
    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}

```

第一个是一个公共方法，不同的构建版本中 $mount 方法有些区别，这边以 runtime + compile 版本为例，在带编译版本中的实现


```js
//  .src/platforms/web/runtime/index.js，只保留了关键代码
// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}

```



```js

```


```js

```
