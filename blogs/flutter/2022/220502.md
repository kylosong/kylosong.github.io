---
title: Flutter基础
date: 2022-05-06
# subSidebar: false
isTimeLine: true
isComment: false
tags:
 - Flutter
categories:
 - Flutter
---

## Widgets 介绍

Widget 具有不同的生命周期：它们是不可变的，它们会存在于状态被改变之前, 每当widget或其状态发生变化时，Flutter的框架都会创建一个新的widget实例树。

与View不同，flutter的Widget很轻巧，部分原因在于它的不变性。因为它本身不是视图，并且不是直接绘制任何东西，而是对UI及其语义的描述

Flutter包含了Material组件库，这些widgets遵循了Materail设计规范。材料设计是一个灵活的设计系统，并且为包括IOS在内的所有系统进行了优化。

在Flutter中，widget是不可变的，不会直接更新。相反，我们可以通过操纵widget的状态来更新它们。这就是有状态和无状态widget概念的来源

无状态widget和有状态widget之间的重要区别在于StatefulWidgets具有一个State对象，该对象存储状态数据并将其传递到树重建中，因此状态不会丢失。

> 请记住以下规则：如果widget在build之外更改（例如，由于运行时用户交互），则它是有状态的。如果widget永远不会改变，一旦构建，它就是无状态的。但是，即使widget是有状态的，如果包含它的父窗口小部件本身不对这些更改（或其他输入）做出反应，父widget仍然可以是无状态的。



### 无状态的(StatelessWidget)
无状态widget的build方法通常只会在以下三种情况调用
* 将widget插入树中时
* 当widget的父级更改其配置时
* 当它依赖的InheritedWidget发生变化时

```js
new Text(
    'hello word',
    style: new TextStyle(fontWeight: FontWeight.bold),
)
```


### 有状态的(StatefulWidget)
Checkbox，Radio，Slider，InkWell，Form和TextField都是有状态的widge，也是StatefulWidget的子类

```js
class Demo extends StatefulWidget {
    Demo({ Key key }) : super(key:key);
    
    @override
    _DemoState createState() => _DemoState();
}

class _DemoState extends State<Demo> {
    String textToShow = 'hhhhh';
    
    void _updateText(){
        setState(() => {
            textToShow = 'Hello';  
        });    
    }
    
    @override
    Widget build(BuildContext context) {
        return Scaffold(
            appBar: AppBar(
                title: Text('Sample App')            
            ),
            body: Center(
                child: Text(textToShow),
                floatingActionButton: FloatingActionButton(
                    onPressed: _updateText,
                    tooltip: 'Update Text',
                    child: Icon(Icons.update),                
                )            
            )        
        );    
    }
}
```

管理状态有三种主要方式：
* 每个widget管理自己的状态
* 父widget管理widget的状态
* 混合搭配管理的方法

如何决定使用哪种方式时，可以参考以下原则：
* 如何所讨论的状态是用户数据，例如复选框的已选中或未选中状态，或滑块的位置，
则状态最好由父widget管理；
* 如何widget的状态取决于动作，例如动画，那么最好由widget自身来管理状态
* 如有还是不确定谁管理状态，请让父widget管理子widget的状态


### Widget库的使用
* 在Flutter中，要使用Material Design库中的小部件，则需要导入 material.dart包。
* 要使用IOS样式widget，请导入Cupertino库。
* 要使用更基本的窗口widget集，请导入widget库。
* 也可以导入自己编写的widget

```js
import 'package:flutter/material.dart'; // 导入系统 material widget库
import 'package:flutter/cupertino.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter/my_widgets.dart';
```

无论你导入哪个widget包，Dart都只会导入在你的应用中使用的widget, 每个窗口widget都嵌套在父窗口widget中，并从其父窗口中继承属性。甚至应用程序对象本身也是一个组件，没有单独的“应用程序”对象。




## 资源、依赖和本地化

在flutter中assets可以是任意类型的文件，而不仅仅是图片。

```js
首先在pubspec.yaml文件中声明 assets

assets:
    - my-assets/data.json

然后在代码中我们可以通过AssetBundle来访问它

import 'dart:async' show Future;
import 'package:flutter/services.dart' show rooBundle;

Future<String> loadAssets() async {
    return await rootBundle.loadString('my-assets/data.json');
}

把图片（1.0x）放置到images文件夹中，并把其它分辨率的图片放在对应的子文件夹中，并接上合适的比例系数即可 
images/my_icon.png
images/2.0x/my_icon.png
images/3.0x/my_icon.png

接下来可以在pubspec.yaml文件中这样声明这个图片资源：

assets:
    - images/my_icon.png

现在，我们可以借助 AssetsImage 来访问它

return AssetImage('images/my_icon.png')

也可以通过Image widget直接使用：

@override
Widget build(BuildContext context) {
    return Image.asset('images/my_icon.png')
}
```

Flutter目前没有专门的字符串资源系统。目前，最佳做法是将strings资源作为静态字段保存在类中。

```js
class Strings {
    static String name = 'zhangsan';
}

然后可以：
Text(Strings.name)
```

默认情况下，Flutter只支持美式英语字符串。如果你要支持其他语言，请引入flutter_localizations包。

你可能也要引入intl包来支持其他i10n机制，比如日期/时间格式化设置代理，这些都是根据插件配置的，具体用法插件会介绍

Flutter使用Dart构建系统和Pub包管理器来处理依赖。这些工具将Android和IOS native 包装应用程序的构建委派给相应的构建系统

在Flutter中，虽然在Flutter项目中的Android文件夹下有Gradle文件，但只有在添加平台相关所需的依赖关系时才使用这些文件。否则，应该使用pubspec.yaml来声明
用于Flutter的外部依赖项。

IOS在Podfile中添加



## 如何进行布局？
1、使用自身的一些属性比如 padding 等等  // 了解怎样设置这些值，比如 padding: EdgeInsets.only(left: 10.0, right: 10.0)

2、或者包裹一些其它的widget

3、在flutter中样式也是一个widget


## 如何对Widget做动画？
在flutter中，使用动画库来包裹widgets，而不是创建一个动画widget。

AnimationController

CurvedAnimation




## 如何绘图
类似Android中的canvas绘图

CustomPaint

CustomPainter



## 如何构建自定义widgets？
在Flutter中，推荐组合多个小的widgets来构建一个自定义widget（而不是扩展它）

举个栗子，如果你要构建一个CustomButton，并在构造器中传入它的label？那就组合RaisedButton和label，而不是扩展RaisedButton




## 如何设置widget的透明度？
可以给widget包裹一个 Opacity widget

```js
Opacity(
    opacity: 0.5,
    child: Text('透明度50%')
)
```





## 布局和列表

### row 水平布局
```js
return Row(
    mainAxisAlignment: MainAxisAlignment.center,
    children: <Widget>[
        Text('One'),
        Text('Two'),
        Text('Three'),
        Text('Four')    
    ]
);
```

### column 垂直布局
```js
return Column(
    mainAxisAlignment: MainAxisAlignment.center,
    children: <Widget>[
        Text('One'),
        Text('Two'),
        Text('Three'),
        Text('Four')    
    ]
);
```

### RelativeLayout
可以通过Column、Row和Stack的组合实现 RelativeLayout 效果

可参考：stackoverflow，Equivalent of Relativelayout in Flutter


### 如何使用widget定义布局属性？

1、可以使用自身属性

2、使用各个小widget进行组合


### 如何分层布局？

Flutter使用Stack widget控制子widget在一层。子widgets可以完全或者部分覆盖基础widgets

Stack控件将其子项相对于其框的边缘定位。如果你只想重叠多个子窗口小部件，这个类很有用

```js
Stack(
    alignment: const Alignment(0.6, 0.6), // 设置布局位置
    children:<Widget>[
        CircleAvatar(
            backgroundImage: NetworImage('picture address')        
        ),
        Container(
            decoration: BoxDecoration(
                color: Color.black45,            
            ),
            child: Text('Flutter')        
        )    
    ]
)
```


### 如何设置布局样式？

Text widget可以使用TextStyle属性。如果要在多个位置使用相同的文本样式，你可以创建一个 TextStyle 类并将其应用于各个 Text widgets 中


### Scrollview 在Flutter中等价于什么？

ListView

```js
return ListView(
    children: <Widget>[
        Text('one'),
        Text('two'),
        Text('three'),
        Text('four')  
    ]
);

List<Widget> widgets = [];
```


更新ListView数据的时候，数据量小的时候可以重新创建一个List

数据量大的时候，更推荐的做法是使用ListView.Builder来构建列表，这个方法在你想要构建动态列表，或是列表拥有大量数据时会非常好用



## 路由导航
在Flutter中，有两个主要的widget用于在页面之间的导航：
* Route 是一个应用程序抽象的屏幕或页面
* Navigator 是一个管理路由的widget

以上两种widget对应flutter 中实现页面导航的有两种选择：
* 具体指定一个由路由名构成的Map（MaterialApp）
* 直接跳转到一个路由。（WidgetApp）


## 言论

* 责任的分离将更大的复杂性封装在各个 widget 中，保证了父级的简单性。